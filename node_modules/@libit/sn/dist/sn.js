"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveCacheFilePath = exports.snSync = exports.sn = exports.digest = exports.COMMANDS = exports.DEFAULT_KEYS = void 0;
const tslib_1 = require("tslib");
const path_1 = tslib_1.__importDefault(require("path"));
const fs = tslib_1.__importStar(require("fs-extra"));
const utils_1 = require("./utils");
exports.DEFAULT_KEYS = ['Serial', 'UUID'];
exports.COMMANDS = {
    darwin: {
        keys: exports.DEFAULT_KEYS,
        cmd: 'system_profiler SPHardwareDataType | grep',
    },
    linux: {
        keys: () => (process.arch === 'arm' ? ['Serial'] : exports.DEFAULT_KEYS),
        cmd: () => (process.arch === 'arm' ? 'cat /proc/cpuinfo | grep' : 'dmidecode -t system | grep'),
    },
    win32: {
        cmd: 'wmic csproduct get IdentifyingNumber',
    },
    freebsd: {
        keys: exports.DEFAULT_KEYS,
        cmd: 'dmidecode -t system | grep',
    },
};
const IGNORES = [/To be filled by O\.E\.M\./i];
exports.digest = utils_1.digester('sha256');
/**
 * Retrieve the serial number form system asynchronously
 *
 * @param options The options object.
 * @param options.cwd The custom current working directory
 * @param options.file The custom cache file name
 * @param options.prefix A string to be prefixed ahead of the shell
 *  command to be run. Can be used to specify a path to the `dmidecode` binary
 *  on *nix systems if it won't be found in the environment $PATH
 * @param options.sudo True to prefix the system command with `sudo`.
 *  Default is false
 * @param options.uuid True to instead try to get the UUID on the
 *  first attempt. Default is false
 * @param options.hash True to return the hashed serial number,
 *  or pass a custom hash function to digest. Default is false.
 * @param options.size Slice the serial number to specified size
 */
async function sn(options = {}) {
    let answer = await retrieve(options);
    if (answer) {
        answer = postprocess(answer, options);
    }
    return answer;
}
exports.sn = sn;
function snSync(options = {}) {
    let answer = retrieveSync(options);
    if (answer) {
        answer = postprocess(answer, options);
    }
    return answer;
}
exports.snSync = snSync;
function postprocess(serial, options = {}) {
    if (options.hash) {
        const hash = typeof options.hash === 'function' ? options.hash : exports.digest;
        serial = hash(serial);
    }
    if (options.size) {
        serial = serial.substr(0, options.size);
    }
    return serial;
}
async function retrieve(options) {
    const commands = findCommands(options);
    for (const command of commands) {
        const answer = await utils_1.execute(command, { ignores: IGNORES });
        if (answer)
            return answer;
    }
    // retrieve from cache
    const file = resolveCacheFilePath(options);
    if (await fs.pathExists(file)) {
        return (await fs.readFile(file, 'utf8')).trim();
    }
}
function retrieveSync(options) {
    const commands = findCommands(options);
    for (const command of commands) {
        const answer = utils_1.executeSync(command, { ignores: IGNORES });
        if (answer)
            return answer;
    }
    // retrieve from cache
    const file = resolveCacheFilePath(options);
    if (fs.pathExistsSync(file)) {
        return fs.readFileSync(file, 'utf8').trim();
    }
}
function findCommands(options) {
    var _a;
    const platform = exports.COMMANDS[process.platform];
    if (!platform) {
        throw new Error('Cannot provide serial number for ' + process.platform);
    }
    const cmd = typeof platform.cmd === 'function' ? platform.cmd() : platform.cmd;
    let keys = typeof platform.keys === 'function' ? platform.keys() : platform.keys;
    if (options.uuid && keys) {
        keys = keys.reverse();
    }
    keys = keys !== null && keys !== void 0 ? keys : [''];
    const prefix = (_a = options.prefix) !== null && _a !== void 0 ? _a : (options.sudo ? 'sudo ' : '');
    return keys.map(key => `${prefix}${cmd} ${key}`);
}
function resolveCacheFilePath(options = {}) {
    var _a, _b;
    const cwd = (_a = options.cwd) !== null && _a !== void 0 ? _a : process.cwd();
    const file = (_b = options.file) !== null && _b !== void 0 ? _b : '.sn';
    return path_1.default.resolve(cwd, file);
}
exports.resolveCacheFilePath = resolveCacheFilePath;
//# sourceMappingURL=sn.js.map